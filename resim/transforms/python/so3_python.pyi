from __future__ import annotations
import resim.transforms.python.quaternion
import typing
__all__ = ['SO3']
class SO3:
    DIMS: typing.ClassVar[int] = 3
    DOF: typing.ClassVar[int] = 3
    @staticmethod
    def identity() -> SO3:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, quaternion: resim.transforms.python.quaternion.Quaternion) -> None:
        ...
    @typing.overload
    def __mul__(self, arg0: SO3) -> SO3:
        ...
    @typing.overload
    def __mul__(self, arg0: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def exp(self: numpy.ndarray[numpy.float64[3, 1]]) -> SO3:
        ...
    def interp(self, fraction: float) -> SO3:
        ...
    def inverse(self) -> SO3:
        ...
    def is_approx(self, other: SO3, precision: float = 1e-12) -> bool:
        ...
    def log(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def quaternion(self) -> resim.transforms.python.quaternion.Quaternion:
        ...
    def rotate(self, source_vector: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def rotation_matrix(self) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
